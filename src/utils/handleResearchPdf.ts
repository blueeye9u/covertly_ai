import pdfMake from "pdfmake/build/pdfmake";
import htmlToPdfMake from "html-to-pdfmake";
import showdown from 'showdown';
import { BOLD_GARMOND_FONT_64, GARMOND_FONT_64, ITALIC_GARMOND_FONT_64 } from "../assets/fonts";

// Configure pdfMake fonts
pdfMake.vfs = {
  'garamond.ttf': GARMOND_FONT_64,
  'garamond-bold.ttf': BOLD_GARMOND_FONT_64,
  'garamond-italic.ttf': ITALIC_GARMOND_FONT_64,
};

pdfMake.fonts = {
  Garamond: {
    normal: 'garamond.ttf',
    bold: 'garamond-bold.ttf',
    italics: 'garamond-italic.ttf',
    bolditalics: 'garamond-italic.ttf',
  },
};

export interface ResearchReportData {
  title: string;
  query: string;
  response: string;
  metadata: any;
  sources: any[];
  chainOfThought: any;
  createdAt: string;
}

export const generateResearchPdf = async (reportData: ResearchReportData) => {
  try {
    const pdfContent = await createResearchPdfContent(reportData);
    
    const docDefinition: any = {
      content: pdfContent,
      styles: {
        title: {
          fontSize: 18,
          bold: true,
          margin: [0, 0, 0, 10],
          alignment: "center",
          color: '#2563eb'
        },
        subtitle: {
          fontSize: 14,
          bold: true,
          margin: [0, 15, 0, 5],
          color: '#1f2937'
        },
        sectionTitle: {
          fontSize: 12,
          bold: true,
          margin: [0, 10, 0, 5],
          color: '#374151'
        },
        paragraph: {
          fontSize: 10,
          lineHeight: 1.4,
          margin: [0, 0, 0, 5]
        },
        metadata: {
          fontSize: 9,
          color: '#6b7280',
          margin: [0, 5, 0, 5]
        },
        source: {
          fontSize: 9,
          margin: [0, 3, 0, 3],
          color: '#374151'
        }
      },
      defaultStyle: {
        font: "Garamond",
        fontFallback: 'sans-serif',
        fontSize: 10,
      },
      pageMargins: [40, 60, 40, 60],
      header: {
        text: 'Deep Research Report - Generated by Covertly AI',
        alignment: 'center',
        fontSize: 8,
        color: '#6b7280',
        margin: [0, 20, 0, 0]
      },
      footer: function(currentPage: number, pageCount: number) {
        return {
          text: `Page ${currentPage} of ${pageCount}`,
          alignment: 'center',
          fontSize: 8,
          color: '#6b7280',
          margin: [0, 0, 0, 20]
        };
      }
    };
    console.log(docDefinition);
    // Generate and download PDF
    pdfMake.createPdf(docDefinition).download(`Research_Report_${new Date().toISOString().split('T')[0]}.pdf`);
  } catch (error) {
    console.error('PDF generation failed:', error);
    throw error;
  }
};

const createResearchPdfContent = async (reportData: ResearchReportData) => {
  const content = [
    {
      text: reportData.title || 'Deep Research Report',
      style: 'title'
    },
    {
      text: [
        { text: 'Generated on: ', style: 'metadata' },
        { text: new Date(reportData.createdAt).toLocaleDateString(), style: 'metadata' },
        { text: ' | Query: ', style: 'metadata' },
        { text: reportData.query || 'N/A', style: 'metadata' }
      ],
      alignment: 'center',
      margin: [0, 0, 0, 20]
    }
  ];

  if (reportData.chainOfThought) {
    content.push(
      { text: 'Research Plan', style: 'subtitle' },
      ...formatResearchPlan(reportData.chainOfThought),
      { text: 'Research Process', style: 'subtitle' },
      ...formatChainOfThought(reportData.chainOfThought)
    );
  }

  if (reportData.sources && reportData.sources.length > 0) {
    content.push(
      { text: 'Sources Analyzed', style: 'subtitle' },
      ...(formatSources(reportData.sources) as any[])
    );
  }

  if (reportData.response) {
    const responseContent = await convertMarkdownToPdfMake(reportData.response);
    content.push(
      { text: 'Complete Research Findings', style: 'subtitle' },
      { stack: responseContent, margin: [0, 0, 0, 15] } as any
    );
  }

  if (reportData.metadata) {
    content.push(
      { text: 'Research Methodology', style: 'subtitle' },
      {
        text: [
          `Sources Processed: ${reportData.metadata.totalSources || 'N/A'}\n`,
          `Search Queries: ${reportData.metadata.searchQueries || 'N/A'}\n`,
          `Processing Time: ${reportData.metadata.processingTime ? (reportData.metadata.processingTime / 1000).toFixed(2) + 's' : 'N/A'}\n`,
          `Analysis Engine: Deep Research Agent with Tavily Search`
        ],
        style: 'paragraph',
        margin: [0, 0, 0, 15]
      } as any
    );
  }

  return content;
};

const convertMarkdownToPdfMake = async (markdown: string) => {
  const converter = new showdown.Converter({ tables: true });
  const html = converter.makeHtml(markdown);
  return htmlToPdfMake(html);
};

const formatResearchPlan = (plan: any) => {
  const content = [];
  
  if (plan.originalQuery) {
    content.push({
      text: `Original Query: ${plan.originalQuery}`,
      style: 'paragraph',
      margin: [0, 0, 0, 10]
    });
  }

  if (plan.factsSurvey) {
    const factsContent = [];
    
    if (plan.factsSurvey.givenFacts && plan.factsSurvey.givenFacts.length > 0) {
      factsContent.push(
        { text: 'Given Facts:', style: 'sectionTitle' },
        ...plan.factsSurvey.givenFacts.map((fact: string) => ({
          text: `• ${fact}`, 
          style: 'paragraph', 
          margin: [15, 0, 0, 3]
        }))
      );
    }

    if (plan.factsSurvey.factsToLookUp && plan.factsSurvey.factsToLookUp.length > 0) {
      factsContent.push(
        { text: 'Facts to Research:', style: 'sectionTitle' },
        ...plan.factsSurvey.factsToLookUp.map((fact: string) => ({
          text: `• ${fact}`, 
          style: 'paragraph', 
          margin: [15, 0, 0, 3]
        }))
      );
    }
    
    content.push(...factsContent);
  }

  if (plan.steps && plan.steps.length > 0) {
    const stepsContent = [
      { text: 'Research Steps:', style: 'sectionTitle' },
      ...plan.steps.map((step: any, index: number) => ({
        text: `${index + 1}. ${step.tool}: ${step.purpose}`,
        style: 'paragraph',
        margin: [15, 0, 0, 5]
      }))
    ];
    content.push(...stepsContent);
  }

  content.push({ text: '', margin: [0, 0, 0, 15] }); // Add spacing
  return content;
};

const formatChainOfThought = (chainOfThought: any) => {
  const content = [];
  
  if (chainOfThought.steps && chainOfThought.steps.length > 0) {
    const stepsContent = chainOfThought.steps.flatMap((step: any, index: number) => {
      const stepContent = [
        {
          text: `Step ${index + 1}: ${step.tool}`,
          style: 'sectionTitle'
        },
        {
          text: `Purpose: ${step.purpose}`,
          style: 'paragraph',
          margin: [15, 0, 0, 3]
        },
        {
          text: `Status: ${step.completed ? 'Completed' : 'Pending'}`,
          style: 'paragraph',
          margin: [15, 0, 0, 3]
        }
      ];

      if (step.query) {
        stepContent.push({
          text: `Query: "${step.query}"`,
          style: 'paragraph',
          margin: [15, 0, 0, 3]
        });
      }

      if (step.results?.answer) {
        stepContent.push({
          text: `Key Finding: ${step.results.answer.substring(0, 200)}...`,
          style: 'paragraph',
          margin: [15, 0, 0, 8]
        });
      }

      return stepContent;
    });
    
    content.push(...stepsContent);
  }

  content.push({ text: '', margin: [0, 0, 0, 15] });
  return content;
};

const formatSources = (sources: any[]) => {
  const sortedSources = sources
      .toSorted((a, b) => (b.credibilityScore + b.score) - (a.credibilityScore + a.score));

  return sortedSources.map((source, index) => ({
    table: {
      widths: ['auto', '*'],
      body: [
        [
          { 
            text: `[${index + 1}]`, 
            style: 'source', 
            bold: true, 
            color: '#2563eb',
            border: [false, false, false, false]
          },
          { 
            text: source.title || 'Untitled Source', 
            style: 'source', 
            bold: true,
            border: [false, false, false, false]
          }
        ],
        [
          { 
            text: '', 
            border: [false, false, false, false] 
          },
          { 
            text: source.url || 'No URL', 
            style: 'source', 
            color: '#6b7280',
            border: [false, false, false, false]
          }
        ],
        [
          { 
            text: '', 
            border: [false, false, false, false] 
          },
          { 
            text: `Credibility: ${source.credibilityScore || 'N/A'}/10 | Relevance: ${source.score || 'N/A'}/10`, 
            style: 'source', 
            color: '#6b7280',
            border: [false, false, false, false]
          }
        ],
        ...(source.summary ? [[
          { 
            text: '', 
            border: [false, false, false, false] 
          },
          { 
            text: source.summary.substring(0, 150) + (source.summary.length > 150 ? '...' : ''), 
            style: 'source',
            border: [false, false, false, false]
          }
        ]] : [])
      ]
    },
    layout: 'noBorders',
    margin: [0, 3, 0, 8]
  }));
};